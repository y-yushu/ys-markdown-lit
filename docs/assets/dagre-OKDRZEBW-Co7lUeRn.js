import{p as h,b as L,i as F,a as M,e as j,F as i,h as Y,X as $,r as H,$ as K,Z,v as q,n as D,L as z,c as Q,K as U}from"./mermaid.js";import{L as k}from"./graph-CHs3MDbZ.js";import{o as V}from"./layout-BB-la_F-.js";import{E as b}from"./_baseUniq-CcP6avan.js";import{a as W}from"./clone-Dbqn34BQ.js";import{g as A}from"./_basePickBy-DNqsubjT.js";import"./index.vue_vue_type_script_setup_true_lang.js";import"./index.js";import"./ys-md-rendering.es.js";import"./ref-4EgzFnS5.js";import"./consume-CNX1KxBo.js";import"./_commonjsHelpers-C6fGbg64.js";import"./Button.js";import"./Table.js";function w(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:_(e),edges:ee(e)};return b(e.graph())||(r.value=W(e.graph())),r}function _(e){return A(e.nodes(),function(r){var n=e.node(r),d=e.parent(r),a={v:r};return b(n)||(a.value=n),b(d)||(a.parent=d),a})}function ee(e){return A(e.edges(),function(r){var n=e.edge(r),d={v:r.v,w:r.w};return b(r.name)||(d.name=r.name),b(n)||(d.value=n),d})}var s=new Map,X=new Map,G=new Map,ne=h(()=>{X.clear(),G.clear(),s.clear()},"clear"),I=h((e,r)=>{const n=X.get(r)||[];return i.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),re=h((e,r)=>{const n=X.get(r)||[];return i.info("Descendants of ",r," is ",n),i.info("Edge is ",e),e.v===r||e.w===r?!1:n?n.includes(e.v)||I(e.v,r)||I(e.w,r)||n.includes(e.w):(i.debug("Tilt, ",r,",not in descendants"),!1)},"edgeInCluster"),J=h((e,r,n,d)=>{i.warn("Copying children of ",e,"root",d,"data",r.node(e),d);const a=r.children(e)||[];e!==d&&a.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(o=>{if(r.children(o).length>0)J(o,r,n,d);else{const c=r.node(o);i.info("cp ",o," to ",d," with parent ",e),n.setNode(o,c),d!==r.parent(o)&&(i.warn("Setting parent",o,r.parent(o)),n.setParent(o,r.parent(o))),e!==d&&o!==e?(i.debug("Setting parent",o,e),n.setParent(o,e)):(i.info("In copy ",e,"root",d,"data",r.node(e),d),i.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==d,"node!==clusterId",o!==e));const g=r.edges(o);i.debug("Copying Edges",g),g.forEach(p=>{i.info("Edge",p);const f=r.edge(p.v,p.w,p.name);i.info("Edge data",f,d);try{re(p,d)?(i.info("Copying as ",p.v,p.w,f,p.name),n.setEdge(p.v,p.w,f,p.name),i.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):i.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",d," clusterId:",e)}catch(m){i.error(m)}})}i.debug("Removing node",o),r.removeNode(o)})},"copy"),P=h((e,r)=>{const n=r.children(e);let d=[...n];for(const a of n)G.set(a,e),d=[...d,...P(a,r)];return d},"extractDescendants"),te=h((e,r,n)=>{const d=e.edges().filter(g=>g.v===r||g.w===r),a=e.edges().filter(g=>g.v===n||g.w===n),o=d.map(g=>({v:g.v===r?n:g.v,w:g.w===r?r:g.w})),c=a.map(g=>({v:g.v,w:g.w}));return o.filter(g=>c.some(p=>g.v===p.v&&g.w===p.w))},"findCommonEdges"),C=h((e,r,n)=>{const d=r.children(e);if(i.trace("Searching children of id ",e,d),d.length<1)return e;let a;for(const o of d){const c=C(o,r,n),g=te(r,n,c);if(c)if(g.length>0)a=c;else return c}return a},"findNonClusterChild"),O=h(e=>!s.has(e)||!s.get(e).externalConnections?e:s.has(e)?s.get(e).id:e,"getAnchorId"),ie=h((e,r)=>{if(!e||r>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(i.warn("Cluster identified",n," Replacement id in edges: ",C(n,e,n)),X.set(n,P(n,e)),s.set(n,{id:C(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const d=e.children(n),a=e.edges();d.length>0?(i.debug("Cluster identified",n,X),a.forEach(o=>{const c=I(o.v,n),g=I(o.w,n);c^g&&(i.warn("Edge: ",o," leaves cluster ",n),i.warn("Descendants of XXX ",n,": ",X.get(n)),s.get(n).externalConnections=!0)})):i.debug("Not a cluster ",n,X)});for(let n of s.keys()){const d=s.get(n).id,a=e.parent(d);a!==n&&s.has(a)&&!s.get(a).externalConnections&&(s.get(n).id=a)}e.edges().forEach(function(n){const d=e.edge(n);i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let a=n.v,o=n.w;if(i.warn("Fix XXX",s,"ids:",n.v,n.w,"Translating: ",s.get(n.v)," --- ",s.get(n.w)),s.get(n.v)||s.get(n.w)){if(i.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),a=O(n.v),o=O(n.w),e.removeEdge(n.v,n.w,n.name),a!==n.v){const c=e.parent(a);s.get(c).externalConnections=!0,d.fromCluster=n.v}if(o!==n.w){const c=e.parent(o);s.get(c).externalConnections=!0,d.toCluster=n.w}i.warn("Fix Replacing with XXX",a,o,n.name),e.setEdge(a,o,d,n.name)}}),i.warn("Adjusted Graph",w(e)),B(e,0),i.trace(s)},"adjustClustersAndEdges"),B=h((e,r)=>{if(i.warn("extractor - ",r,w(e),e.children("D")),r>10){i.error("Bailing out");return}let n=e.nodes(),d=!1;for(const a of n){const o=e.children(a);d=d||o.length>0}if(!d){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",n,r);for(const a of n)if(i.debug("Extracting node",a,s,s.has(a)&&!s.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",r),!s.has(a))i.debug("Not a cluster",a,r);else if(!s.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){i.warn("Cluster without external connections, without a parent and with children",a,r);let o=e.graph().rankdir==="TB"?"LR":"TB";s.get(a)?.clusterData?.dir&&(o=s.get(a).clusterData.dir,i.warn("Fixing dir",s.get(a).clusterData.dir,o));const c=new k({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",w(e)),J(a,e,c,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:s.get(a).clusterData,label:s.get(a).label,graph:c}),i.warn("New graph after copy node: (",a,")",w(c)),i.debug("Old graph after copy",w(e))}else i.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!s.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),r),i.debug(s);n=e.nodes(),i.warn("New list of nodes",n);for(const a of n){const o=e.node(a);i.warn(" Now next level",a,o),o?.clusterNode&&B(o.graph,r+1)}},"extractor"),T=h((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(d=>{const a=e.children(d),o=T(e,a);n=[...n,...o]}),n},"sorter"),ae=h(e=>T(e,e.children()),"sortNodesByHierarchy"),R=h(async(e,r,n,d,a,o)=>{i.warn("Graph in recursive render:XAX",w(r),a);const c=r.graph().rankdir;i.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");r.nodes()?i.info("Recursive render XXX",r.nodes()):i.info("No nodes found for",r),r.edges().length>0&&i.info("Recursive edges",r.edge(r.edges()[0]));const p=g.insert("g").attr("class","clusters"),f=g.insert("g").attr("class","edgePaths"),m=g.insert("g").attr("class","edgeLabels"),y=g.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(l){const t=r.node(l);if(a!==void 0){const u=JSON.parse(JSON.stringify(a.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,l,`
 data=`,u.height,`
Parent cluster`,a.height),r.setNode(a.id,u),r.parent(l)||(i.trace("Setting parent",l,a.id),r.setParent(l,a.id,u))}if(i.info("(Insert) Node XXX"+l+": "+JSON.stringify(r.node(l))),t?.clusterNode){i.info("Cluster identified XBX",l,t.width,r.node(l));const{ranksep:u,nodesep:E}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:u+25,nodesep:E});const N=await R(y,t.graph,n,d,r.node(l),o),x=N.elem;$(t,x),t.diff=N.diff||0,i.info("New compound node after recursive render XAX",l,"width",t.width,"height",t.height),H(x,t)}else r.children(l).length>0?(i.trace("Cluster - the non recursive path XBX",l,t.id,t,t.width,"Graph:",r),i.trace(C(t.id,r)),s.set(t.id,{id:C(t.id,r),node:t})):(i.trace("Node - the non recursive path XAX",l,y,r.node(l),c),await K(y,r.node(l),{config:o,dir:c}))})),await h(async()=>{const l=r.edges().map(async function(t){const u=r.edge(t.v,t.w,t.name);i.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),i.info("Fix",s,"ids:",t.v,t.w,"Translating: ",s.get(t.v),s.get(t.w)),await Z(m,u)});await Promise.all(l)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(w(r))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),V(r),i.info("Graph after layout:",JSON.stringify(w(r)));let v=0,{subGraphTitleTotalMargin:S}=q(o);return await Promise.all(ae(r).map(async function(l){const t=r.node(l);if(i.info("Position XBX => "+l+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t?.clusterNode)t.y+=S,i.info("A tainted cluster node XBX1",l,t.id,t.width,t.height,t.x,t.y,r.parent(l)),s.get(t.id).node=t,D(t);else if(r.children(l).length>0){i.info("A pure cluster node XBX1",l,t.id,t.x,t.y,t.width,t.height,r.parent(l)),t.height+=S,r.node(t.parentId);const u=t?.padding/2||0,E=t?.labelBBox?.height||0,N=E-u||0;i.debug("OffsetY",N,"labelHeight",E,"halfPadding",u),await z(p,t),s.get(t.id).node=t}else{const u=r.node(t.parentId);t.y+=S/2,i.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",u,u?.offsetY,t),D(t)}})),r.edges().forEach(function(l){const t=r.edge(l);i.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(t),t),t.points.forEach(x=>x.y+=S/2);const u=r.node(l.v);var E=r.node(l.w);const N=Q(f,t,s,n,u,E,d);U(t,N)}),r.nodes().forEach(function(l){const t=r.node(l);i.info(l,t.type,t.diff),t.isGroup&&(v=t.diff)}),i.warn("Returning from recursive render XAX",g,v),{elem:g,diff:v}},"recursiveRender"),Xe=h(async(e,r)=>{const n=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),d=r.select("g");L(d,e.markers,e.type,e.diagramId),F(),M(),j(),ne(),e.nodes.forEach(o=>{n.setNode(o.id,{...o}),o.parentId&&n.setParent(o.id,o.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(o=>{if(o.start===o.end){const c=o.start,g=c+"---"+c+"---1",p=c+"---"+c+"---2",f=n.node(c);n.setNode(g,{domId:g,id:g,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(g,f.parentId),n.setNode(p,{domId:p,id:p,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(p,f.parentId);const m=structuredClone(o),y=structuredClone(o),v=structuredClone(o);m.label="",m.arrowTypeEnd="none",m.id=c+"-cyclic-special-1",y.arrowTypeStart="none",y.arrowTypeEnd="none",y.id=c+"-cyclic-special-mid",v.label="",f.isGroup&&(m.fromCluster=c,v.toCluster=c),v.id=c+"-cyclic-special-2",v.arrowTypeStart="none",n.setEdge(c,g,m,c+"-cyclic-special-0"),n.setEdge(g,p,y,c+"-cyclic-special-1"),n.setEdge(p,c,v,c+"-cyc<lic-special-2")}else n.setEdge(o.start,o.end,{...o},o.id)}),i.warn("Graph at first:",JSON.stringify(w(n))),ie(n),i.warn("Graph after XAX:",JSON.stringify(w(n)));const a=Y();await R(d,n,e.type,e.diagramId,void 0,a)},"render");export{Xe as render};
